use aoc_23::day_one::{prepare_input, sum_calibration_values, INPUT};
use std::collections::HashSet;
fn main() {
    let test = "1abctwo3four";
    let split_numbers = ["1", "2", "3", "4", "5", "6", "7", "8", "9","one", "two", "three", "four", "five", "six", "seven", "eight", "nine"];

    //ways to quickly solve:
    //1. create large hashset of all possible numbers and use a sliding growing window to find and
    //collect the digits in the string.
    //
    let mut words : HashSet<&str>= HashSet::from_iter(split_numbers.iter().cloned());
    let letters = test.chars().collect::<Vec<char>>();
    let mut numbers = Vec::new(); 
    for i in 0..letters.len() {
        for j in i..letters.len()+1 {
            let word = &letters[i..j];
            println!("word: {:?}", word);
            let word = word.iter().collect::<String>();
            if words.contains(word.as_str()) {
                numbers.push(word);
                
                println!("found word: {}", word);
            }
        }
    }
}

fn convert_vec_to_num(vec: Vec<&str>) -> u32 {
    let mut num: String = "".to_string();
    if vec.len() == 1 {
        num.push_str(vec[0]);
        num.push_str(vec[0]);
    } else {
        num.push_str(vec[0]);
        num.push_str(vec[vec.len()-1]);
    }
    num.parse::<u32>().unwrap()
}
